PUSH//   if ( x < Tree -> Key)   //Если нововведенный элемент x меньше чем элемент x из семечка дерева, уходим влево
        {
          if ( Tree -> L != 0) { Tree -> L = T -> L -> L; push( x);} //При помощи рекурсии заталкиваем элемент на свободный участок
          else          //Если элемент получил свой участок, то
		  {
           Tree -> L = new Node;                 //Выделяем память левому подзвену. Именно подзвену, а не просто звену
           Tree -> L -> L = Tree -> L -> R = 0;   //У левого подзвена будут свои левое и правое подзвенья, инициализируем их пустотой
           Tree-> L -> Key = x;                     //Записываем в левое подзвено записываемый элемент
          }
        }
        if ( x > Tree -> Key)              //Если нововведенный элемент x больше чем элемент x из семечка дерева, уходим вправо
        {    
		  if( Tree -> R != 0) { Tree -> R = T -> R -> R; push( x);} //При помощи рекурсии заталкиваем элемент на свободный участок
          else              //Если элемент получил свой участок, то
          {
            Tree -> R = new Node;                 //Выделяем память правому подзвену. Именно подзвену, а не просто звену
            Tree -> R -> L = Tree -> R -> R = 0;   //У правого подзвена будут свои левое и правое подзвенья, инициализируем их пустотой
            Tree -> R -> Key = x;                     //Записываем в правое подзвено записываемый элемент
          }
        }